<!DOCTYPE html>
<html>
<head>
    <title>Interactive Map with Draggable Objects</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        #map {
            height: 100vh;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <!-- Leaflet Path Drag Plugin -->
    <!--<script src="https://unpkg.com/leaflet-path-drag@1.9.5/dist/index.js"></script>-->
    <script src="custom-leaflet-path-drag.js"></script>
    <script>
        // Initialize the map
        var map = L.map('map').setView([20, 0], 2); // Centered at latitude 20, longitude 0, zoom level 2

        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);
        
        // Function to split MultiPolygon into Polygons
        function splitMultiPolygon(geojson) {
            var features = [];
            if (geojson.geometry.type === "MultiPolygon") {
                geojson.geometry.coordinates.forEach(function(polygonCoords) {
                    var polygon = {
                        "type": "Feature",
                        "properties": geojson.properties,
                        "geometry": {
                            "type": "Polygon",
                            "coordinates": polygonCoords
                        }
                    };
                    features.push(polygon);
                });
            } else if (geojson.geometry.type === "Polygon") {
                features.push(geojson);
            }
            return features;
        }

        function calculateCentroid(geometry) {
            var latSum = 0, lngSum = 0, count = 0;
            
            if (geometry.type === "Polygon") {
                geometry.coordinates[0].forEach(function(coord) {
                    lngSum += coord[0];
                    latSum += coord[1];
                    count++;
                });
            } else if (geometry.type === "MultiPolygon") {
                geometry.coordinates.forEach(function(polygon) {
                    polygon[0].forEach(function(coord) {
                        lngSum += coord[0];
                        latSum += coord[1];
                        count++;
                    });
                });
            }
            
            return [latSum / count, lngSum / count];
        }        

        // Function to add draggable GeoJSON Polygon to the map
        function addDraggablePolygon(geojson) {
            var layer = L.geoJSON(geojson, {
                style: {
                    color: 'blue',
                    weight: 2,
                    fillOpacity: 0.2
                }
            }).addTo(map);

            // Enable dragging
            layer.eachLayer(function(l) {
                if (l.dragging) {
                    l.dragging.enable();
                } else {
                    l.dragging = new L.Handler.PathDrag(l);
                    l.dragging.enable();
                }
/*
                // Optional: Handle drag events
                l.on('drag', function (e) {
                    console.log(e);
                    //console.log(l);
                    //console.log(l.getLatLngs());
                    var newCoords = calculateCentroid(l.getLatLngs());
                    console.log(geojson.properties.name + ' moved to:', newCoords);
                });
                */
            });
        }

        // Function to transform GeoJSON coordinates
        function translateAllCoordinates(geojson, offsetX, offsetY) {
            var transformed = JSON.parse(JSON.stringify(geojson)); // Deep copy
            function transformCoord(coord) {
                return [coord[0] + offsetX, coord[1] + offsetY];
            }
            function traverseCoords(coords) {
                if (typeof coords[0] === 'number') {
                    return transformCoord(coords);
                } else {
                    return coords.map(traverseCoords);
                }
            }
            if (transformed.type === 'FeatureCollection') {
                transformed.features.forEach(function(feature) {
                    feature.geometry.coordinates = traverseCoords(feature.geometry.coordinates);
                });
            } else if (transformed.type === 'Feature') {
                transformed.geometry.coordinates = traverseCoords(transformed.geometry.coordinates);
            } else {
                transformed.coordinates = traverseCoords(transformed.coordinates);
            }

            return transformed;
        }


        // Load GeoJSON data (you can replace this with your own GeoJSON)
        // For demonstration, we'll use a sample country GeoJSON (e.g., France)
        fetch('https://raw.githubusercontent.com/johan/world.geo.json/master/countries/RUS.geo.json')
            .then(function(response) {
                return response.json();
            })
            .then(function(geojson) {
                geojson.features.forEach(function(feature) {
                    var individualPolygons = splitMultiPolygon(feature);
                    individualPolygons.forEach(function(polygon) {
                        addDraggablePolygon(polygon);
                    });
                });                
            })
            .catch(function(error) {
                console.error('Error loading GeoJSON:', error);
            });

            fetch('https://raw.githubusercontent.com/johan/world.geo.json/master/countries/GRC.geo.json')
            .then(function(response) {
                return response.json();
            })
            .then(function(geojson) {
                geojson.features.forEach(function(feature) {
                    var individualPolygons = splitMultiPolygon(feature);
                    individualPolygons.forEach(function(polygon) {
                        addDraggablePolygon(polygon);
                    });
                });                
            })
            .catch(function(error) {
                console.error('Error loading GeoJSON:', error);
            });

            fetch('https://raw.githubusercontent.com/johan/world.geo.json/master/countries/GRL.geo.json')
            .then(function(response) {
                return response.json();
            })
            .then(function(geojson) {
                geojson.features.forEach(function(feature) {
                    var individualPolygons = splitMultiPolygon(feature);
                    individualPolygons.forEach(function(polygon) {
                        addDraggablePolygon(polygon);
                    });
                });                
            })
            .catch(function(error) {
                console.error('Error loading GeoJSON:', error);
            });






    </script>
</body>
</html>